"""
Caktus Dashboard — FastAPI backend
Manages Docker container deployments via a vintage terminal UI.
"""

import io
import json
import os
import re
import time
import tarfile
from pathlib import Path
from typing import Optional

import docker
from docker.errors import NotFound, APIError, BuildError, ImageNotFound
from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import HTMLResponse, JSONResponse, StreamingResponse
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel, field_validator

# ── Config ────────────────────────────────────────────────────────────────────

NGINX_APPS_DIR = Path(os.getenv("NGINX_APPS_DIR", "/nginx-apps"))
DATA_DIR = Path(os.getenv("DATA_DIR", "/data"))
APPS_FILE = DATA_DIR / "apps.json"
DOCKER_NETWORK = "caktus-net"
CONTAINER_PREFIX = "caktus-app-"
NGINX_CONTAINER = "caktus-nginx"
NGROK_DOMAIN = os.getenv("NGROK_DOMAIN", "")

# ── App ───────────────────────────────────────────────────────────────────────

app = FastAPI(title="Caktus Dashboard", docs_url=None, redoc_url=None)

# ── State ─────────────────────────────────────────────────────────────────────


def _load_apps() -> dict:
    if APPS_FILE.exists():
        try:
            return json.loads(APPS_FILE.read_text())
        except (json.JSONDecodeError, OSError):
            return {}
    return {}


def _save_apps(apps: dict):
    DATA_DIR.mkdir(parents=True, exist_ok=True)
    APPS_FILE.write_text(json.dumps(apps, indent=2))


def _docker_client() -> docker.DockerClient:
    return docker.from_env()


# ── Models ────────────────────────────────────────────────────────────────────


class DeployRequest(BaseModel):
    name: str
    port: int
    image: Optional[str] = None
    dockerfile: Optional[str] = None
    env_vars: Optional[str] = ""  # KEY=VALUE per line

    @field_validator("name")
    @classmethod
    def validate_name(cls, v):
        v = v.strip().lower()
        if not re.match(r"^[a-z0-9][a-z0-9-]{0,30}$", v):
            raise ValueError(
                "Name must be lowercase alphanumeric/hyphens, 1-31 chars"
            )
        reserved = {"nginx", "ngrok", "portainer", "uptime", "dashboard", "hello", "landing"}
        if v in reserved:
            raise ValueError(f"'{v}' is a reserved service name")
        return v

    @field_validator("port")
    @classmethod
    def validate_port(cls, v):
        if not 1 <= v <= 65535:
            raise ValueError("Port must be between 1 and 65535")
        return v


# ── Helpers ───────────────────────────────────────────────────────────────────


def _container_name(app_name: str) -> str:
    return f"{CONTAINER_PREFIX}{app_name}"


def _write_nginx_conf(app_name: str, port: int):
    """Write an nginx location block for the deployed app."""
    NGINX_APPS_DIR.mkdir(parents=True, exist_ok=True)
    conf_path = NGINX_APPS_DIR / f"{app_name}.conf"
    container = _container_name(app_name)

    conf = f"""# Auto-generated by Caktus Dashboard — do not edit
location /apps/{app_name}/ {{
    proxy_pass http://{container}:{port}/;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $connection_upgrade;
}}
"""
    conf_path.write_text(conf)


def _remove_nginx_conf(app_name: str):
    conf_path = NGINX_APPS_DIR / f"{app_name}.conf"
    if conf_path.exists():
        conf_path.unlink()


def _reload_nginx():
    """Send SIGHUP to nginx to reload config without downtime."""
    try:
        client = _docker_client()
        nginx = client.containers.get(NGINX_CONTAINER)
        nginx.kill(signal="SIGHUP")
    except Exception:
        pass  # Non-fatal — nginx will pick up on next restart


def _get_container_status(app_name: str) -> str:
    try:
        client = _docker_client()
        c = client.containers.get(_container_name(app_name))
        return c.status
    except NotFound:
        return "not found"
    except Exception:
        return "unknown"


def _parse_env_vars(env_str: str) -> list[str]:
    """Parse KEY=VALUE newline-separated string into Docker env list."""
    if not env_str or not env_str.strip():
        return []
    result = []
    for line in env_str.strip().splitlines():
        line = line.strip()
        if line and "=" in line and not line.startswith("#"):
            result.append(line)
    return result


def _build_image_from_dockerfile(app_name: str, dockerfile_content: str) -> str:
    """Build a Docker image from Dockerfile content string."""
    client = _docker_client()
    tag = f"caktus-app-{app_name}:latest"

    # Create an in-memory tar with the Dockerfile
    dockerfile_bytes = dockerfile_content.encode("utf-8")
    fileobj = io.BytesIO()
    with tarfile.open(fileobj=fileobj, mode="w") as tar:
        info = tarfile.TarInfo(name="Dockerfile")
        info.size = len(dockerfile_bytes)
        tar.addfile(info, io.BytesIO(dockerfile_bytes))
    fileobj.seek(0)

    image, logs = client.images.build(
        fileobj=fileobj,
        custom_context=True,
        tag=tag,
        rm=True,
        forcerm=True,
    )
    return tag


# ── API Routes ────────────────────────────────────────────────────────────────


@app.get("/", response_class=HTMLResponse)
async def root():
    html_path = Path(__file__).parent / "static" / "index.html"
    return HTMLResponse(content=html_path.read_text(), status_code=200)


@app.get("/api/health")
async def health():
    return {"status": "ok", "timestamp": int(time.time())}


@app.get("/api/info")
async def info():
    """System info for the UI status bar."""
    ngrok_url = f"https://{NGROK_DOMAIN}" if NGROK_DOMAIN else ""
    return {
        "ngrok_domain": NGROK_DOMAIN,
        "ngrok_url": ngrok_url,
        "network": DOCKER_NETWORK,
    }


@app.get("/api/apps")
async def list_apps():
    apps = _load_apps()
    result = []
    for name, meta in apps.items():
        status = _get_container_status(name)
        public_url = ""
        if NGROK_DOMAIN:
            public_url = f"https://{NGROK_DOMAIN}/apps/{name}/"
        result.append(
            {
                "name": name,
                "image": meta.get("image", ""),
                "port": meta.get("port", 0),
                "status": status,
                "deployed_at": meta.get("deployed_at", ""),
                "public_url": public_url,
                "local_url": f"http://localhost/apps/{name}/",
                "env_count": len(meta.get("env_vars", [])),
            }
        )
    return result


@app.post("/api/deploy")
async def deploy(req: DeployRequest):
    apps = _load_apps()

    # Check for duplicates
    if req.name in apps:
        raise HTTPException(400, f"App '{req.name}' already exists. Delete it first.")

    # Need either image or dockerfile
    if not req.image and not req.dockerfile:
        raise HTTPException(400, "Provide either an image name or Dockerfile content.")

    client = _docker_client()
    image_tag = req.image or ""
    build_log = []

    try:
        # ── Build or pull image ───────────────────────────────────────
        if req.dockerfile:
            build_log.append(f"[build] Building image from Dockerfile...")
            image_tag = _build_image_from_dockerfile(req.name, req.dockerfile)
            build_log.append(f"[build] Image built: {image_tag}")
        else:
            build_log.append(f"[pull] Pulling image: {image_tag}...")
            try:
                client.images.get(image_tag)
                build_log.append(f"[pull] Image found locally")
            except ImageNotFound:
                client.images.pull(image_tag)
                build_log.append(f"[pull] Image pulled from registry")

        # ── Parse env vars ────────────────────────────────────────────
        env_list = _parse_env_vars(req.env_vars or "")
        if env_list:
            build_log.append(f"[env] {len(env_list)} environment variable(s) set")

        # ── Create and start container ────────────────────────────────
        container_name = _container_name(req.name)
        build_log.append(f"[run] Creating container: {container_name}")

        container = client.containers.run(
            image=image_tag,
            name=container_name,
            detach=True,
            network=DOCKER_NETWORK,
            restart_policy={"Name": "unless-stopped"},
            environment=env_list if env_list else None,
            labels={
                "caktus.managed": "true",
                "caktus.app": req.name,
            },
        )
        build_log.append(f"[run] Container started: {container.short_id}")

        # ── Write nginx conf ─────────────────────────────────────────
        _write_nginx_conf(req.name, req.port)
        build_log.append(f"[nginx] Route written: /apps/{req.name}/")

        # ── Reload nginx ──────────────────────────────────────────────
        _reload_nginx()
        build_log.append(f"[nginx] Configuration reloaded")

        # ── Save state ────────────────────────────────────────────────
        apps[req.name] = {
            "image": image_tag,
            "port": req.port,
            "deployed_at": time.strftime("%Y-%m-%d %H:%M:%S"),
            "env_vars": env_list,
        }
        _save_apps(apps)

        public_url = ""
        if NGROK_DOMAIN:
            public_url = f"https://{NGROK_DOMAIN}/apps/{req.name}/"

        build_log.append(f"[done] App '{req.name}' is live!")
        if public_url:
            build_log.append(f"[url] {public_url}")

        return {
            "success": True,
            "name": req.name,
            "public_url": public_url,
            "local_url": f"http://localhost/apps/{req.name}/",
            "log": build_log,
        }

    except BuildError as e:
        build_log.append(f"[error] Build failed: {str(e)}")
        return JSONResponse(
            status_code=500,
            content={"success": False, "log": build_log, "error": str(e)},
        )
    except APIError as e:
        build_log.append(f"[error] Docker API error: {str(e)}")
        # Cleanup on failure
        try:
            c = client.containers.get(_container_name(req.name))
            c.remove(force=True)
        except Exception:
            pass
        _remove_nginx_conf(req.name)
        return JSONResponse(
            status_code=500,
            content={"success": False, "log": build_log, "error": str(e)},
        )
    except Exception as e:
        build_log.append(f"[error] Unexpected error: {str(e)}")
        return JSONResponse(
            status_code=500,
            content={"success": False, "log": build_log, "error": str(e)},
        )


@app.delete("/api/apps/{app_name}")
async def delete_app(app_name: str):
    apps = _load_apps()
    if app_name not in apps:
        raise HTTPException(404, f"App '{app_name}' not found")

    client = _docker_client()
    log = []

    # Stop and remove container
    try:
        container = client.containers.get(_container_name(app_name))
        container.stop(timeout=10)
        container.remove()
        log.append(f"[stop] Container removed")
    except NotFound:
        log.append(f"[stop] Container already gone")
    except Exception as e:
        log.append(f"[stop] Error: {str(e)}")

    # Remove nginx conf
    _remove_nginx_conf(app_name)
    _reload_nginx()
    log.append(f"[nginx] Route removed, config reloaded")

    # Remove from state
    del apps[app_name]
    _save_apps(apps)
    log.append(f"[done] App '{app_name}' deleted")

    return {"success": True, "log": log}


@app.get("/api/apps/{app_name}/logs")
async def app_logs(app_name: str, tail: int = 100):
    apps = _load_apps()
    if app_name not in apps:
        raise HTTPException(404, f"App '{app_name}' not found")

    try:
        client = _docker_client()
        container = client.containers.get(_container_name(app_name))
        logs = container.logs(tail=tail, timestamps=True).decode("utf-8", errors="replace")
        return {"name": app_name, "logs": logs}
    except NotFound:
        return {"name": app_name, "logs": "[container not found]"}
    except Exception as e:
        return {"name": app_name, "logs": f"[error fetching logs: {str(e)}]"}
